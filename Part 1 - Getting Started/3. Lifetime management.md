# Управление жизненным циклом

Идея Rx состоит в том, что несмотря на то, что неизвестно, *когда* последовательность посылает новые данные или завершается, у вас всё равно остаётся контроль над тем, когда начать или перестать получать их. Также, подписки могут быть привязаны к выделенным ресурсам, которые вы хотели бы освободить по окончании последовательности. И это можно сделать средствами Rx.

## Подписка

Существуют несколько сокращённых перегрузок `Observable.subscribe`:

```java
Subscription 	subscribe()
Subscription 	subscribe(Action1<? super T> onNext)
Subscription 	subscribe(Action1<? super T> onNext, Action1<java.lang.Throwable> onError)
Subscription 	subscribe(Action1<? super T> onNext, Action1<java.lang.Throwable> onError, Action0 onComplete)
Subscription 	subscribe(Observer<? super T> observer)
Subscription 	subscribe(Subscriber<? super T> subscriber)
```

`Subscriber`, полученный вызовом `subscribe()`, получает уведомления о событиях, но никак на них не реагирует. Перегруженные версии, принимающие один или более `Action`, создадут `Subscriber` с указанным вами функционалом. Если не указывать действие, можно считать, что событие будет проигнорировано.

В приведённом примере рассмотрена обработка ошибки возникшей при генерации последовательности.

```java
Subject<Integer, Integer> s = ReplaySubject.create();
s.subscribe(
	v -> System.out.println(v),
	e -> System.err.println(e));
s.onNext(0);
s.onError(new Exception("Oops"));
```

Вывод
```
0
java.lang.Exception: Oops
```

Если мы не укажем функцию обработки ошибок, то в момент вызова `s.onError` со стороны поставщика будет *брошено* исключение `OnErrorNotImplementedException`. В данном случае поставщик и потребитель находятся рядом, потому можно было бы использовать традиционный try-catch. Но в случае раздробленной системы поставщик и потребитель, часто, находятся в совершенно разных местах. Потребитель никогда не узнает о том, что случилась ошибка приведшая к завершению последовательности, если не предоставит обработчика ошибок при вызове `subscribe`.

## Отписка

Возможно также отказаться от последующих сообщений ещё до того, как последовательность завершится. Каждый перегруженный метод `subscribe` возвращает экземпляр объекта `Subscription` который реализует интерфейс с двумя методами:

```java
boolean isUnsubscribed()
void unsubscribe()
```

Вызов `unsubscribe` предотвратит отправку новых событий наблюдателю.

```java
Subject<Integer, Integer>  values = ReplaySubject.create();
Subscription subscription = values.subscribe(
    v -> System.out.println(v),
    e -> System.err.println(e),
    () -> System.out.println("Done")
);
values.onNext(0);
values.onNext(1);
subscription.unsubscribe();
values.onNext(2);
```
[Вывод](/tests/java/itrx/chapter1/UnsubscribingExample.java)
```
0
1
```

Отписка одного наблюдателя никак не влияет на других наблюдателей следящих за тем же объектом. 

```java
Subject<Integer, Integer>  values = ReplaySubject.create();
Subscription subscription1 = values.subscribe(
    v -> System.out.println("First: " + v)
);
Subscription subscription2 = values.subscribe(
	v -> System.out.println("Second: " + v)
);
values.onNext(0);
values.onNext(1);
subscription1.unsubscribe();
System.out.println("Unsubscribed first");
values.onNext(2);
```
[Вывод](/tests/java/itrx/chapter1/UnsubscribingExample.java)
```
First: 0
Second: 0
First: 1
Second: 1
Unsubscribed first
Second: 2
```

## onError и onCompleted

`onError` и `onCompleted` сообщают об окончании последовательности. Наблюдаемый объект, исполняющий контракт Rx, не отправит ничего более своим подписчикам после свершения любого из этих событий. Имейте это в виду при реализации потребителей и наблюдаемых объектов с использованием Rx.

```java
Subject<Integer, Integer>  values = ReplaySubject.create();
Subscription subscription1 = values.subscribe(
    v -> System.out.println("First: " + v),
    e -> System.out.println("First: " + e),
    () -> System.out.println("Completed")
);
values.onNext(0);
values.onNext(1);
values.onCompleted();
values.onNext(2);
```
[Вывод](/tests/java/itrx/chapter1/RxContractExample.java)
```
First: 0
First: 1
Completed
```

## Освобождение ресурсов

`Subscription` связана с используемыми ею ресурсами, потому следует помнить о необходимости утилизации подписок. Для этого можно создать привязку между `Subscription` и необходимыми ресурсами при помощи фабрики [Subscriptions](http://reactivex.io/RxJava/javadoc/rx/subscriptions/Subscriptions.html).

```java
Subscription s = Subscriptions.create(() -> System.out.println("Clean"));
s.unsubscribe();
```
[Вывод](/tests/java/itrx/chapter1/UnsubscribingExample.java)
```
Clean
```

Действие, которое необходимо выполнить после отписки, может быть передано при вызове `Subscriptions.create`. Так же имеются сокращения для типичных задач, которые можно использовать при создании подписки.
* `Subscriptions.empty()` возвращает `Subscription`, которое не предпринимает никаких действий при утилизации. Может пригодиться, если вам нужно возвратить экземпляр `Subscription`, но ваша реализация не требует освобождения никаких ресурсов.
* `Subscriptions.from(Subscription... subscriptions)` возвращает `Subscription`, которая утилизирует другие подписки вслед за собой.
* `Subscriptions.unsubscribed()` возвращает `Subscription`, которая уже утилизирована.

Существуют несколько готовых реализаций `Subscription`:

* `BooleanSubscription`
* `CompositeSubscription`
* `MultipleAssignmentSubscription`
* `RefCountSubscription`
* `SafeSubscriber`
* `Scheduler.Worker`
* `SerializedSubscriber`
* `SerialSubscription`
* `Subscriber`
* `TestSubscriber`

Мы рассмотрим их далее в этой книге. Примечательно, что `Subscriber` также реализует `Subscription`. Это означает, что мы можем использовать ссылку на `Subscriber` для остановки последовательности.

#### Продолжить чтение

| Назад | Вперёд |
| --- | --- |
| [Ключевые типы](/Part 1 - Getting Started/2. Key types.md) | [Часть 2](/Part 2 - Sequence Basics/1. Creating a sequence.md) |
